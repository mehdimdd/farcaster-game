<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Pong ‚Äì Pay to Play</title>
  <style>
    html, body { height:100%; margin:0; }
    body { background:black; display:flex; align-items:center; justify-content:center; }
    canvas { border:2px solid white; }

    .overlay {
      position:fixed; inset:0; display:grid; place-items:center;
      background:rgba(0,0,0,.8); color:white; font-family:sans-serif;
    }
    button {
      background:#1dd979; border:0; padding:10px 20px; border-radius:10px;
      color:#04130c; font-weight:700; cursor:pointer; margin-top:10px;
    }
    #status { margin-top:8px; font-size:14px; color:#ccc; }
  </style>
</head>
<body>
  <div id="intro" class="overlay">
    <div>
      <h2>üéÆ Pong Game</h2>
      <p>To start, a small Base transaction is required.</p>
      <button id="payPlay">Pay & Play</button>
      <div id="status"></div>
    </div>
  </div>

  <canvas width="750" height="585" id="game"></canvas>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk'
    sdk.actions.ready();

    const USE_BASE_SEPOLIA = false;
    const RECIPIENT = "0x02212a875c56baE7AF27A5a389FD4e8A11442692";
    const AMOUNT_ETH = "0.00001";

    const BASE_MAINNET = { chainId: "0x2105",  explorer: "https://basescan.org/tx/" };
    const BASE_SEPOLIA = { chainId: "0x14a34", explorer: "https://sepolia.basescan.org/tx/" };
    const TARGET = USE_BASE_SEPOLIA ? BASE_SEPOLIA : BASE_MAINNET;

    const statusEl = document.getElementById("status");
    const show = msg => { statusEl.innerHTML += msg + "<br>"; };

    function parseEther(x){
      const [w,f=""]=String(x).split('.'); const frac=(f+'0'.repeat(18)).slice(0,18);
      return '0x'+(BigInt(w)*10n**18n+BigInt(frac)).toString(16);
    }
    async function getProvider(){
      try { const p = await sdk.wallet.getEthereumProvider(); if (p) return p; } catch {}
      return window.ethereum ?? null;
    }
    async function ensureChain(provider, chainId) {
      const current = (await provider.request({ method:'eth_chainId' }))?.toLowerCase();
      if (current === chainId.toLowerCase()) return;
      try {
        await provider.request({ method:'wallet_switchEthereumChain', params:[{ chainId }] });
      } catch (e) {
        if (e?.code === 4902) {
          await provider.request({ method:'wallet_addEthereumChain', params:[{ chainId }] });
          await provider.request({ method:'wallet_switchEthereumChain', params:[{ chainId }] });
        } else { throw e; }
      }
    }
    async function requiredPayment() {
      show("üîç Locating wallet‚Ä¶");
      const provider = await getProvider();
      if (!provider) throw new Error("No wallet");
      show("‚úÖ Wallet ready.");
      const [from] = await provider.request({ method:'eth_requestAccounts' });
      show("üëõ " + from.slice(0,6)+"‚Ä¶"+from.slice(-4));
      await ensureChain(provider, TARGET.chainId);
      show("üîÑ On Base network.");
      const hash = await provider.request({
        method:'eth_sendTransaction',
        params:[{ from, to:RECIPIENT, value:parseEther(AMOUNT_ETH) }]
      });
      show(`‚úÖ TX sent. <a target="_blank" href="${TARGET.explorer}${hash}">View</a>`);
      return hash;
    }

    document.getElementById("payPlay").addEventListener("click", async () => {
      try {
        document.getElementById("payPlay").disabled = true;
        await requiredPayment();
        document.getElementById("intro").style.display = "none";
        startPong();
      } catch(e) {
        show("‚ùå Payment required to play.");
      } finally {
        document.getElementById("payPlay").disabled = false;
      }
    });

    /* === Original Pong code === */
    function startPong(){
      const canvas = document.getElementById('game');
      const context = canvas.getContext('2d');
      const grid = 15;
      const paddleHeight = grid * 5;
      const maxPaddleY = canvas.height - grid - paddleHeight;
      let paddleSpeed = 6, ballSpeed = 5;
      const left = { x:grid*2, y:canvas.height/2 - paddleHeight/2, width:grid, height:paddleHeight, dy:0 };
      const right = { x:canvas.width - grid*3, y:canvas.height/2 - paddleHeight/2, width:grid, height:paddleHeight, dy:0 };
      const ball = { x:canvas.width/2, y:canvas.height/2, width:grid, height:grid, dx:ballSpeed, dy:-ballSpeed, resetting:false };

      function collides(a,b){ return a.x<b.x+b.width && a.x+a.width>b.x && a.y<b.y+b.height && a.y+a.height>b.y; }

      function loop(){
        requestAnimationFrame(loop);
        context.clearRect(0,0,canvas.width,canvas.height);
        left.y+=left.dy; right.y+=right.dy;
        if(left.y<grid) left.y=grid; else if(left.y>maxPaddleY) left.y=maxPaddleY;
        if(right.y<grid) right.y=grid; else if(right.y>maxPaddleY) right.y=maxPaddleY;

        context.fillStyle='white';
        context.fillRect(left.x,left.y,left.width,left.height);
        context.fillRect(right.x,right.y,right.width,right.height);

        ball.x+=ball.dx; ball.y+=ball.dy;
        if(ball.y<grid||ball.y+grid>canvas.height-grid){ ball.dy*=-1; }

        if((ball.x<0||ball.x>canvas.width)&&!ball.resetting){
          ball.resetting=true;
          setTimeout(()=>{ball.resetting=false; ball.x=canvas.width/2; ball.y=canvas.height/2;},400);
        }

        if(collides(ball,left)){ ball.dx*=-1; ball.x=left.x+left.width; }
        else if(collides(ball,right)){ ball.dx*=-1; ball.x=right.x-ball.width; }

        context.fillRect(ball.x,ball.y,ball.width,ball.height);
        context.fillStyle='lightgrey';
        context.fillRect(0,0,canvas.width,grid);
        context.fillRect(0,canvas.height-grid,canvas.width,canvas.height);
        for(let i=grid;i<canvas.height-grid;i+=grid*2)
          context.fillRect(canvas.width/2-grid/2,i,grid,grid);
      }

      document.addEventListener('keydown',e=>{
        if(e.which===38) right.dy=-paddleSpeed;
        else if(e.which===40) right.dy=paddleSpeed;
        if(e.which===87) left.dy=-paddleSpeed;
        else if(e.which===83) left.dy=paddleSpeed;
      });
      document.addEventListener('keyup',e=>{
        if([38,40].includes(e.which)) right.dy=0;
        if([83,87].includes(e.which)) left.dy=0;
      });
      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
