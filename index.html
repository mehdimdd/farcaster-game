<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Pong ‚Äì Pay to Play</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    canvas {
      border: 2px solid white;
      width: 90vw;
      max-width: 480px;
      aspect-ratio: 4 / 3;
      background: black;
      touch-action: none;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      text-align: center;
      padding: 20px;
    }

    button {
      background: #1dd979;
      border: 0;
      padding: 10px 20px;
      border-radius: 10px;
      color: #04130c;
      font-weight: 700;
      cursor: pointer;
      margin-top: 10px;
    }

    #status { margin-top: 8px; font-size: 14px; color: #ccc; }

    #lossCounter {
      color: #1dd979;
      font-size: 18px;
      margin-top: 5px;
      font-weight: bold;
    }

    /* Mobile controls */
    #mobile-controls { display: none; margin-top: 10px; gap: 10px; }
    .ctrl-btn {
      width: 70px; height: 70px; font-size: 24px; border-radius: 12px; border: none;
      background: #1dd979; color: #04130c; font-weight: bold; cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    }
    @media (max-width: 720px) { #mobile-controls { display: flex; } }
  </style>
</head>
<body>
  <div id="intro" class="overlay">
    <div>
      <h2>üéÆ Pong Game</h2>
      <p id="intro-msg">To start, a small Base transaction is required.</p>
      <button id="payPlay">Pay & Play</button>
      <div id="status"></div>
    </div>
  </div>

  <div id="lossCounter"></div>
  <canvas id="game"></canvas>

  <!-- On-screen mobile controls -->
  <div id="mobile-controls">
    <button class="ctrl-btn" id="btn-up">‚Üë</button>
    <button class="ctrl-btn" id="btn-down">‚Üì</button>
  </div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    sdk.actions.ready();

    /* ===== Config ===== */
    const USE_BASE_SEPOLIA = false;
    const RECIPIENT = "0xB60Be01ACbe65390A08f34fE513443A0dcEa59f1";
    const AMOUNT_ETH = "0.00001";
    const BASE_MAINNET = { chainId: "0x2105",  explorer: "https://basescan.org/tx/" };
    const BASE_SEPOLIA = { chainId: "0x14a34", explorer: "https://sepolia.basescan.org/tx/" };
    const TARGET = USE_BASE_SEPOLIA ? BASE_SEPOLIA : BASE_MAINNET;

    /* ===== UI Helpers ===== */
    const introEl  = document.getElementById('intro');
    const introMsg = document.getElementById('intro-msg');
    const statusEl = document.getElementById('status');
    const lossEl   = document.getElementById('lossCounter');
    const show = msg => { statusEl.innerHTML += msg + "<br>"; };
    const clearStatus = () => { statusEl.innerHTML = ""; };

    let totalLosses = 0; // üßÆ track total losses

    /* ===== Payment helpers ===== */
    function parseEther(x){
      const [w,f=""]=String(x).split('.'); const frac=(f+'0'.repeat(18)).slice(0,18);
      return '0x'+(BigInt(w)*10n**18n+BigInt(frac)).toString(16);
    }
    async function getProvider(){
      try { const p = await sdk.wallet.getEthereumProvider(); if (p) return p; } catch {}
      return window.ethereum ?? null;
    }
    async function ensureChain(provider, chainId) {
      const current = (await provider.request({ method:'eth_chainId' }))?.toLowerCase();
      if (current === chainId.toLowerCase()) return;
      try {
        await provider.request({ method:'wallet_switchEthereumChain', params:[{ chainId }] });
      } catch (e) {
        if (e?.code === 4902) {
          await provider.request({ method:'wallet_addEthereumChain', params:[{ chainId }] });
          await provider.request({ method:'wallet_switchEthereumChain', params:[{ chainId }] });
        } else { throw e; }
      }
    }
    async function requiredPayment() {
      clearStatus();
      show("üîç Connecting wallet‚Ä¶");
      const provider = await getProvider();
      if (!provider) throw new Error("No wallet found");
      show("‚úÖ Wallet ready.");
      const [from] = await provider.request({ method:'eth_requestAccounts' });
      show("üëõ " + from.slice(0,6)+"‚Ä¶"+from.slice(-4));
      await ensureChain(provider, TARGET.chainId);
      show("üîÑ On Base network‚Ä¶");
      const hash = await provider.request({
        method:'eth_sendTransaction',
        params:[{ from, to:RECIPIENT, value:parseEther(AMOUNT_ETH) }]
      });
      show(`‚úÖ TX sent. <a target="_blank" href="${TARGET.explorer}${hash}">View</a>`);
      return hash;
    }

    /* ===== Game lifecycle ===== */
    let pong = null; // will hold game API after first start

    document.getElementById("payPlay").addEventListener("click", async () => {
      try {
        const btn = document.getElementById("payPlay");
        btn.disabled = true;
        await requiredPayment();
        introEl.style.display = "none";
        totalLosses = 0;
        updateLossDisplay();
        if (!pong) {
          pong = startPong();
        } else {
          pong.resumeAfterPayment();
        }
      } catch (e) {
        show("‚ùå Payment required to play.");
      } finally {
        document.getElementById("payPlay").disabled = false;
      }
    });

    function updateLossDisplay() {
      lossEl.textContent = `üíÄ Losses: ${totalLosses}/7`;
    }

    function startPong(){
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      const grid = Math.max(10, canvas.width / 50);
      const paddleHeight = grid * 5;
      const maxPaddleY = canvas.height - grid - paddleHeight;

      let paddleSpeed = 6, ballSpeed = 4;
      let gamePaused = false;
      let rafId = null;

      const bot =    { x:grid*2, y:canvas.height/2 - paddleHeight/2, width:grid, height:paddleHeight };
      const player = { x:canvas.width - grid*3, y:canvas.height/2 - paddleHeight/2, width:grid, height:paddleHeight, dy:0 };
      const ball =   { x:canvas.width/2, y:canvas.height/2, width:grid, height:grid, dx:ballSpeed, dy:-ballSpeed };

      function collides(a,b){ return a.x<b.x+b.width && a.x+a.width>b.x && a.y<b.y+b.height && a.y+a.height>b.y; }

      function resetBall(random=true){
        ball.x = canvas.width/2;
        ball.y = canvas.height/2;
        ball.dx = random ? ballSpeed * (Math.random()>0.5?1:-1) : 0;
        ball.dy = random ? ballSpeed * (Math.random()>0.5?1:-1) : 0;
      }

      function pauseForPayment(){
        gamePaused = true;
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
        ball.dx = 0; ball.dy = 0;
        introMsg.textContent = "You reached 7 losses! Please pay to play again.";
        clearStatus();
        introEl.style.display = "grid";
      }

      function handleLoss(){
        totalLosses++;
        updateLossDisplay();
        if (totalLosses >= 7) {
          pauseForPayment();
          return true;
        }
        return false;
      }

      function loop(){
        if (gamePaused) return;

        ctx.clearRect(0,0,canvas.width,canvas.height);

        // Player movement
        player.y += player.dy;
        if(player.y < grid) player.y = grid;
        else if(player.y > maxPaddleY) player.y = maxPaddleY;

        // Bot AI
        const botCenter = bot.y + bot.height / 2;
        if (botCenter < ball.y - 10) bot.y += paddleSpeed * 0.6;
        else if (botCenter > ball.y + 10) bot.y -= paddleSpeed * 0.6;
        if(bot.y < grid) bot.y = grid;
        else if(bot.y > maxPaddleY) bot.y = maxPaddleY;

        // Ball movement
        ball.x += ball.dx;
        ball.y += ball.dy;

        if(ball.y < grid || ball.y + grid > canvas.height - grid){ ball.dy *= -1; }

        // Out of bounds
        if (ball.x > canvas.width) {
          if (handleLoss()) return; // stop if reached 7
          resetBall(true);
        } else if (ball.x < 0) {
          resetBall(true);
        }

        // Collisions
        if(collides(ball, bot)){ ball.dx *= -1; ball.x = bot.x + bot.width; }
        else if(collides(ball, player)){ ball.dx *= -1; ball.x = player.x - ball.width; }

        // Draw
        ctx.fillStyle='white';
        ctx.fillRect(bot.x, bot.y, bot.width, bot.height);
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.fillRect(ball.x, ball.y, ball.width, ball.height);

        ctx.fillStyle='lightgrey';
        ctx.fillRect(0,0,canvas.width,grid);
        ctx.fillRect(0,canvas.height-grid,canvas.width,canvas.height);
        for(let i=grid;i<canvas.height-grid;i+=grid*2)
          ctx.fillRect(canvas.width/2-grid/2,i,grid,grid);

        rafId = requestAnimationFrame(loop);
      }

      // Controls
      document.addEventListener('keydown',e=>{
        if(e.which===38) player.dy=-paddleSpeed;
        else if(e.which===40) player.dy=paddleSpeed;
      });
      document.addEventListener('keyup',e=>{
        if([38,40].includes(e.which)) player.dy=0;
      });

      // Mobile controls
      const upBtn = document.getElementById('btn-up');
      const downBtn = document.getElementById('btn-down');
      const handleTouchStart = (dir) => { player.dy = dir === 'up' ? -paddleSpeed : paddleSpeed; };
      const handleTouchEnd = () => { player.dy = 0; };
      upBtn.addEventListener('touchstart', () => handleTouchStart('up'));
      downBtn.addEventListener('touchstart', () => handleTouchStart('down'));
      upBtn.addEventListener('touchend', handleTouchEnd);
      downBtn.addEventListener('touchend', handleTouchEnd);

      resetBall(true);
      rafId = requestAnimationFrame(loop);

      return {
        resumeAfterPayment(){
          gamePaused = false;
          totalLosses = 0;
          updateLossDisplay();
          resetBall(true);
          rafId = requestAnimationFrame(loop);
        }
      };
    }
  </script>
</body>
</html>
