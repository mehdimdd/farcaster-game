<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Pong â€“ Pay to Play (Mobile Controls + Music)</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: system-ui, sans-serif;
      touch-action: manipulation; /* ÙŠÙ‚Ù„Ù„ Ø§Ù„Ù„Ù…Ø³Ø§Øª Ø§Ù„ØºÙŠØ± Ù…Ø±ØºÙˆØ¨Ø© */
    }
    canvas {
      border: 2px solid white;
      width: 90vw;
      max-width: 480px;
      aspect-ratio: 4 / 3;
      background: black;
      touch-action: none; /* Ù…Ø§ ÙŠØ¯ÙŠØ±Ø´ Ø³ÙƒØ±ÙˆÙ„ */
    }
    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,0.85);
      color: white;
      text-align: center;
      padding: 20px;
    }
    button {
      background: #1dd979;
      border: 0;
      padding: 10px 20px;
      border-radius: 10px;
      color: #04130c;
      font-weight: 700;
      cursor: pointer;
      margin-top: 10px;
    }
    #status { margin-top: 8px; font-size: 14px; color: #ccc; }
    #lossCounter {
      color: #1dd979;
      font-size: 18px;
      margin-top: 5px;
      font-weight: bold;
    }
    /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ */
    #mobile-controls {
      position: fixed;
      bottom: 14px;
      display: none;
      gap: 12px;
      z-index: 10;
    }
    .ctrl-btn {
      width: 72px;
      height: 72px;
      font-size: 26px;
      border-radius: 14px;
      border: none;
      background: #1dd979;
      color: #04130c;
      font-weight: 800;
      box-shadow: 0 6px 14px rgba(0,0,0,0.35);
      touch-action: none;
      user-select: none;
    }
    @media (max-width: 720px) {
      #mobile-controls { display: flex; }
    }
  </style>
</head>
<body>
  <div id="intro" class="overlay">
    <div>
      <h2>ğŸ® Pong Game</h2>
      <p id="intro-msg">To start, a small Base transaction is required.</p>
      <button id="payPlay">Pay & Play</button>
      <div id="status"></div>
    </div>
  </div>

  <div id="lossCounter"></div>
  <canvas id="game"></canvas>

  <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ -->
  <div id="mobile-controls">
    <button class="ctrl-btn" id="btn-up">â†‘</button>
    <button class="ctrl-btn" id="btn-down">â†“</button>
  </div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    sdk.actions.ready();

    const RECIPIENT = "0xB60Be01ACbe65390A08f34fE513443A0dcEa59f1";
    const AMOUNT_ETH = "0.00001";
    const BASE = { chainId: "0x2105", explorer: "https://basescan.org/tx/" };

    const introEl = document.getElementById('intro');
    const introMsg = document.getElementById('intro-msg');
    const statusEl = document.getElementById('status');
    const lossEl = document.getElementById('lossCounter');
    const show = msg => statusEl.innerHTML += msg + "<br>";
    const clearStatus = () => statusEl.innerHTML = "";

    let pong = null;
    let totalLosses = 0;
    let maxLosses = 7;
    let level = 1;
    let resetAfterCycle = false;
    let firstPlay = true;

    /* ğŸµ Background music */
    let audioCtx, musicNode, musicLoopTimer;
    function startMusic() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      // iOS/Android: Ù„Ø§Ø²Ù… user gestureâ€”Ø²Ø± Pay & Play ÙƒÙŠØ­Ù„Ù‘Ù‡Ø§
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "triangle";
      let t = audioCtx.currentTime;
      const notes = [261.6, 329.6, 392.0, 440.0]; // do mi sol la
      for (let i = 0; i < 64; i++) {
        const n = notes[i % notes.length];
        o.frequency.setValueAtTime(n, t);
        g.gain.setValueAtTime(0.08, t);
        t += 0.25;
      }
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      o.stop(t);
      musicNode = o;
      musicLoopTimer = setTimeout(() => {
        if (!audioCtx) return;
        startMusic();
      }, 16000);
    }
    function stopMusic() {
      try { if (musicNode) musicNode.stop(); } catch {}
      musicNode = null;
      if (musicLoopTimer) clearTimeout(musicLoopTimer);
    }

    function updateLossDisplay() {
      lossEl.textContent = `ğŸ’€ Losses: ${totalLosses}/${maxLosses} | Level ${level}`;
    }

    async function getProvider() {
      try { const p = await sdk.wallet.getEthereumProvider(); if (p) return p; } catch {}
      return window.ethereum ?? null;
    }

    async function requiredPayment() {
      clearStatus();
      show("ğŸ” Connecting walletâ€¦");
      const provider = await getProvider();
      if (!provider) throw new Error("No wallet found");
      show("âœ… Wallet ready.");
      const [from] = await provider.request({ method: "eth_requestAccounts" });
      show("ğŸ‘› " + from.slice(0,6) + "â€¦" + from.slice(-4));
      await provider.request({ method: "wallet_switchEthereumChain", params: [{ chainId: BASE.chainId }] });
      show("ğŸ”„ On Base networkâ€¦");
      const value = "0x" + (BigInt(parseFloat(AMOUNT_ETH) * 1e18)).toString(16);
      const hash = await provider.request({
        method: "eth_sendTransaction",
        params: [{ from, to: RECIPIENT, value }]
      });
      show(`âœ… TX sent. <a target="_blank" href="${BASE.explorer}${hash}">View</a>`);
      return hash;
    }

    document.getElementById("payPlay").addEventListener("click", async () => {
      try {
        const btn = document.getElementById("payPlay");
        btn.disabled = true;
        await requiredPayment();
        introEl.style.display = "none";
        totalLosses = 0;

        if (firstPlay) {
          firstPlay = false;
        } else {
          if (resetAfterCycle) {
            maxLosses = 7;
            level = 1;
            resetAfterCycle = false;
            show("ğŸ” Game Reset â€” back to Level 1!");
          } else if (maxLosses > 1) {
            maxLosses--;
            level++;
            if (maxLosses === 1) resetAfterCycle = true;
          }
        }

        updateLossDisplay();

        if (!pong) pong = startPong();
        else pong.resume();

        startMusic(); // ÙŠØ´ØªØºÙ„ Ø¨Ø¹Ø¯ Ø§Ù„Ø¨Ø¯Ø¡
      } catch {
        show("âŒ Payment required to play.");
      } finally {
        document.getElementById("payPlay").disabled = false;
      }
    });

    function startPong() {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      const grid = Math.max(10, canvas.width / 50);
      const paddleH = grid * 5;
      const maxY = canvas.height - grid - paddleH;
      let paddleSpeed = 6, ballSpeed = 4;
      let paused = false, rafId = null;

      const bot = { x: grid*2, y: canvas.height/2 - paddleH/2, w: grid, h: paddleH };
      const player = { x: canvas.width - grid*3, y: canvas.height/2 - paddleH/2, w: grid, h: paddleH, dy: 0 };
      const ball = { x: canvas.width/2, y: canvas.height/2, w: grid, h: grid, dx: ballSpeed, dy: -ballSpeed };

      function resetBall() {
        ball.x = canvas.width/2;
        ball.y = canvas.height/2;
        ball.dx = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
        ball.dy = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
      }

      function pauseGame() {
        paused = true;
        if (rafId) cancelAnimationFrame(rafId);
        ball.dx = 0; ball.dy = 0;
        stopMusic();
        introMsg.textContent = `You reached ${maxLosses} losses! Please pay to continue.`;
        clearStatus();
        introEl.style.display = "grid";
      }

      function loseRound() {
        totalLosses++;
        updateLossDisplay();
        if (totalLosses >= maxLosses) {
          pauseGame();
          return true;
        }
        resetBall();
        return false;
      }

      function loop() {
        if (paused) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨
        player.y += player.dy;
        if (player.y < grid) player.y = grid;
        else if (player.y > maxY) player.y = maxY;

        // Ø¨ÙˆØª Ø¨Ø³ÙŠØ·
        const botCenter = bot.y + bot.h / 2;
        if (botCenter < ball.y - 10) bot.y += paddleSpeed * 0.6;
        else if (botCenter > ball.y + 10) bot.y -= paddleSpeed * 0.6;

        // Ø­Ø±ÙƒØ© Ø§Ù„ÙƒØ±Ø©
        ball.x += ball.dx;
        ball.y += ball.dy;

        if (ball.y < grid || ball.y + grid > canvas.height - grid) ball.dy *= -1;

        if (ball.x > canvas.width) {
          if (loseRound()) return;
        } else if (ball.x < 0) {
          resetBall();
        }

        // ØªØµØ§Ø¯Ù…Ø§Øª
        if (ball.x < bot.x + bot.w && ball.x + ball.w > bot.x && ball.y < bot.y + bot.h && ball.y + ball.h > bot.y) {
          ball.dx *= -1;
        }
        if (ball.x < player.x + player.w && ball.x + ball.w > player.x && ball.y < player.y + player.h && ball.y + ball.h > player.y) {
          ball.dx *= -1;
        }

        // Ø±Ø³Ù…
        ctx.fillStyle = "white";
        ctx.fillRect(bot.x, bot.y, bot.w, bot.h);
        ctx.fillRect(player.x, player.y, player.w, player.h);
        ctx.fillRect(ball.x, ball.y, ball.w, ball.h);

        rafId = requestAnimationFrame(loop);
      }

      // ÙƒÙŠØ¨ÙˆØ±Ø¯ (Ù„Ù„Ù€PC)
      document.addEventListener("keydown", e => {
        if (e.which === 38) player.dy = -paddleSpeed;
        else if (e.which === 40) player.dy = paddleSpeed;
      });
      document.addEventListener("keyup", e => {
        if ([38, 40].includes(e.which)) player.dy = 0;
      });

      // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ (Ù„Ù…Ø³ + Ù…Ø§ÙˆØ³ Ù„Ù„Ø¶ØºØ· Ø§Ù„Ù…Ø·ÙˆÙ‘Ù„)
      const upBtn = document.getElementById('btn-up');
      const downBtn = document.getElementById('btn-down');
      const startUp = (ev) => { ev.preventDefault(); player.dy = -paddleSpeed; };
      const startDown = (ev) => { ev.preventDefault(); player.dy = paddleSpeed; };
      const stopMove = (ev) => { ev.preventDefault(); player.dy = 0; };

      [['touchstart','mousedown'], ['touchend','mouseup','mouseleave']].forEach((arr, i) => {
        const isStart = i === 0;
        arr.forEach(evt => {
          upBtn.addEventListener(evt, isStart ? startUp : stopMove, { passive: false });
          downBtn.addEventListener(evt, isStart ? startDown : stopMove, { passive: false });
        });
      });

      resetBall();
      updateLossDisplay();
      rafId = requestAnimationFrame(loop);

      return {
        resume() {
          paused = false;
          totalLosses = 0;
          updateLossDisplay();
          resetBall();
          startMusic();
          rafId = requestAnimationFrame(loop);
        }
      };
    }
  </script>
</body>
</html>
