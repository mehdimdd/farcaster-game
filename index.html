<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Pong ‚Äì Pay to Play</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: system-ui, sans-serif;
    }
    canvas {
      border: 2px solid white;
      width: 90vw;
      max-width: 480px;
      aspect-ratio: 4 / 3;
      background: black;
    }
    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,0.85);
      color: white;
      text-align: center;
      padding: 20px;
    }
    button {
      background: #1dd979;
      border: 0;
      padding: 10px 20px;
      border-radius: 10px;
      color: #04130c;
      font-weight: 700;
      cursor: pointer;
      margin-top: 10px;
    }
    #status { margin-top: 8px; font-size: 14px; color: #ccc; }
    #lossCounter {
      color: #1dd979;
      font-size: 18px;
      margin-top: 5px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="intro" class="overlay">
    <div>
      <h2>üéÆ Pong Game</h2>
      <p id="intro-msg">To start, a small Base transaction is required.</p>
      <button id="payPlay">Pay & Play</button>
      <div id="status"></div>
    </div>
  </div>

  <div id="lossCounter"></div>
  <canvas id="game"></canvas>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    sdk.actions.ready();

    const RECIPIENT = "0xB60Be01ACbe65390A08f34fE513443A0dcEa59f1";
    const AMOUNT_ETH = "0.00001";
    const BASE = { chainId: "0x2105", explorer: "https://basescan.org/tx/" };

    const introEl = document.getElementById('intro');
    const introMsg = document.getElementById('intro-msg');
    const statusEl = document.getElementById('status');
    const lossEl = document.getElementById('lossCounter');
    const show = msg => statusEl.innerHTML += msg + "<br>";
    const clearStatus = () => statusEl.innerHTML = "";

    let pong = null;
    let totalLosses = 0;
    let maxLosses = 7; // üß© ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ7
    let level = 1; // ŸÑŸÖÿ™ÿßÿ®ÿπÿ© ÿßŸÑÿµÿπŸàÿ®ÿ©

    function updateLossDisplay() {
      lossEl.textContent = `üíÄ Losses: ${totalLosses}/${maxLosses}  |  Level ${level}`;
    }

    async function getProvider() {
      try { const p = await sdk.wallet.getEthereumProvider(); if (p) return p; } catch {}
      return window.ethereum ?? null;
    }

    async function requiredPayment() {
      clearStatus();
      show("üîç Connecting wallet‚Ä¶");
      const provider = await getProvider();
      if (!provider) throw new Error("No wallet found");
      show("‚úÖ Wallet ready.");
      const [from] = await provider.request({ method: "eth_requestAccounts" });
      show("üëõ " + from.slice(0,6) + "‚Ä¶" + from.slice(-4));
      await provider.request({ method: "wallet_switchEthereumChain", params: [{ chainId: BASE.chainId }] });
      show("üîÑ On Base network‚Ä¶");
      const value = "0x" + (BigInt(parseFloat(AMOUNT_ETH) * 1e18)).toString(16);
      const hash = await provider.request({
        method: "eth_sendTransaction",
        params: [{ from, to: RECIPIENT, value }]
      });
      show(`‚úÖ TX sent. <a target="_blank" href="${BASE.explorer}${hash}">View</a>`);
      return hash;
    }

    document.getElementById("payPlay").addEventListener("click", async () => {
      try {
        const btn = document.getElementById("payPlay");
        btn.disabled = true;
        await requiredPayment();
        introEl.style.display = "none";
        totalLosses = 0;

        // üëá ÿ®ÿπÿØ ÿßŸÑÿ£ÿØÿßÿ°ÿå ŸÜŸÇÿµ ÿπÿØÿØ ÿßŸÑÿÆÿ≥ÿßÿ±ÿßÿ™ ŸÑŸÑŸÖÿ±ÿ© ÿßŸÑÿ¨ÿßŸäÿ©
        if (maxLosses > 1) {
          maxLosses--;
          level++;
        }

        updateLossDisplay();

        if (!pong) pong = startPong();
        else pong.resume();
      } catch {
        show("‚ùå Payment required to play.");
      } finally {
        document.getElementById("payPlay").disabled = false;
      }
    });

    function startPong() {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      const grid = Math.max(10, canvas.width / 50);
      const paddleH = grid * 5;
      const maxY = canvas.height - grid - paddleH;
      let paddleSpeed = 6, ballSpeed = 4;
      let paused = false, rafId = null;

      const bot = { x: grid*2, y: canvas.height/2 - paddleH/2, w: grid, h: paddleH };
      const player = { x: canvas.width - grid*3, y: canvas.height/2 - paddleH/2, w: grid, h: paddleH, dy: 0 };
      const ball = { x: canvas.width/2, y: canvas.height/2, w: grid, h: grid, dx: ballSpeed, dy: -ballSpeed };

      function resetBall() {
        ball.x = canvas.width/2;
        ball.y = canvas.height/2;
        ball.dx = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
        ball.dy = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
      }

      function pauseGame() {
        paused = true;
        if (rafId) cancelAnimationFrame(rafId);
        ball.dx = 0; ball.dy = 0;
        introMsg.textContent = `You reached ${maxLosses} losses! Please pay to continue.`;
        clearStatus();
        introEl.style.display = "grid";
      }

      function loseRound() {
        totalLosses++;
        updateLossDisplay();
        if (totalLosses >= maxLosses) {
          pauseGame();
          return true;
        }
        resetBall();
        return false;
      }

      function loop() {
        if (paused) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        player.y += player.dy;
        if (player.y < grid) player.y = grid;
        else if (player.y > maxY) player.y = maxY;

        const botCenter = bot.y + bot.h / 2;
        if (botCenter < ball.y - 10) bot.y += paddleSpeed * 0.6;
        else if (botCenter > ball.y + 10) bot.y -= paddleSpeed * 0.6;

        ball.x += ball.dx;
        ball.y += ball.dy;
        if (ball.y < grid || ball.y + grid > canvas.height - grid) ball.dy *= -1;

        if (ball.x > canvas.width) {
          if (loseRound()) return;
        } else if (ball.x < 0) resetBall();

        // collisions
        if (ball.x < bot.x + bot.w && ball.x + ball.w > bot.x && ball.y < bot.y + bot.h && ball.y + ball.h > bot.y)
          ball.dx *= -1;
        if (ball.x < player.x + player.w && ball.x + ball.w > player.x && ball.y < player.y + player.h && ball.y + ball.h > player.y)
          ball.dx *= -1;

        ctx.fillStyle = "white";
        ctx.fillRect(bot.x, bot.y, bot.w, bot.h);
        ctx.fillRect(player.x, player.y, player.w, player.h);
        ctx.fillRect(ball.x, ball.y, ball.w, ball.h);

        rafId = requestAnimationFrame(loop);
      }

      document.addEventListener("keydown", e => {
        if (e.which === 38) player.dy = -paddleSpeed;
        else if (e.which === 40) player.dy = paddleSpeed;
      });
      document.addEventListener("keyup", e => {
        if ([38, 40].includes(e.which)) player.dy = 0;
      });

      resetBall();
      updateLossDisplay();
      rafId = requestAnimationFrame(loop);

      return {
        resume() {
          paused = false;
          totalLosses = 0;
          updateLossDisplay();
          resetBall();
          rafId = requestAnimationFrame(loop);
        }
      };
    }
  </script>
</body>
</html>
