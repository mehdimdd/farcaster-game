<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Pong ‚Äì Pay to Play</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    canvas {
      border: 2px solid white;
      width: 90vw;
      max-width: 480px;
      aspect-ratio: 4 / 3;
      background: black;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
      transition: all 0.4s ease;
    }

    button {
      background: #1dd979;
      border: 0;
      padding: 10px 20px;
      border-radius: 10px;
      color: #04130c;
      font-weight: 700;
      cursor: pointer;
      margin-top: 10px;
    }

    #status {
      margin-top: 8px;
      font-size: 14px;
      color: #ccc;
    }

    /* Mobile controls */
    #mobile-controls {
      display: none;
      margin-top: 10px;
      gap: 10px;
    }

    .ctrl-btn {
      width: 70px;
      height: 70px;
      font-size: 24px;
      border-radius: 12px;
      border: none;
      background: #1dd979;
      color: #04130c;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    }

    @media (max-width: 720px) {
      #mobile-controls {
        display: flex;
      }
    }
  </style>
</head>
<body>
  <div id="intro" class="overlay">
    <div>
      <h2>üéÆ Pong Game</h2>
      <p>To start, a small Base transaction is required.</p>
      <button id="payPlay">Pay & Play</button>
      <div id="status"></div>
    </div>
  </div>

  <canvas id="game"></canvas>

  <!-- On-screen mobile controls -->
  <div id="mobile-controls">
    <button class="ctrl-btn" id="btn-up">‚Üë</button>
    <button class="ctrl-btn" id="btn-down">‚Üì</button>
  </div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk'
    sdk.actions.ready();

    const USE_BASE_SEPOLIA = false;
    const RECIPIENT = "0xB60Be01ACbe65390A08f34fE513443A0dcEa59f1";
    const AMOUNT_ETH = "0.00001";

    const BASE_MAINNET = { chainId: "0x2105",  explorer: "https://basescan.org/tx/" };
    const BASE_SEPOLIA = { chainId: "0x14a34", explorer: "https://sepolia.basescan.org/tx/" };
    const TARGET = USE_BASE_SEPOLIA ? BASE_SEPOLIA : BASE_MAINNET;

    const statusEl = document.getElementById("status");
    const show = msg => { statusEl.innerHTML += msg + "<br>"; };

    let lossCount = 0; // ÿπÿØÿØ ÿßŸÑŸÖÿ±ÿßÿ™ ÿßŸÑŸÑŸä ÿÆÿ≥ÿ± ŸÅŸäŸáÿß ÿßŸÑŸÑÿßÿπÿ®

    function parseEther(x){
      const [w,f=""]=String(x).split('.');
      const frac=(f+'0'.repeat(18)).slice(0,18);
      return '0x'+(BigInt(w)*10n**18n+BigInt(frac)).toString(16);
    }

    async function getProvider(){
      try { const p = await sdk.wallet.getEthereumProvider(); if (p) return p; } catch {}
      return window.ethereum ?? null;
    }

    async function ensureChain(provider, chainId) {
      const current = (await provider.request({ method:'eth_chainId' }))?.toLowerCase();
      if (current === chainId.toLowerCase()) return;
      try {
        await provider.request({ method:'wallet_switchEthereumChain', params:[{ chainId }] });
      } catch (e) {
        if (e?.code === 4902) {
          await provider.request({ method:'wallet_addEthereumChain', params:[{ chainId }] });
          await provider.request({ method:'wallet_switchEthereumChain', params:[{ chainId }] });
        } else { throw e; }
      }
    }

    async function requiredPayment() {
      show("üîç Connecting wallet‚Ä¶");
      const provider = await getProvider();
      if (!provider) throw new Error("No wallet found");
      show("‚úÖ Wallet ready.");
      const [from] = await provider.request({ method:'eth_requestAccounts' });
      show("üëõ " + from.slice(0,6)+"‚Ä¶"+from.slice(-4));
      await ensureChain(provider, TARGET.chainId);
      show("üîÑ Switching to Base network‚Ä¶");
      const hash = await provider.request({
        method:'eth_sendTransaction',
        params:[{ from, to:RECIPIENT, value:parseEther(AMOUNT_ETH) }]
      });
      show(`‚úÖ TX sent. <a target="_blank" href="${TARGET.explorer}${hash}">View</a>`);
      return hash;
    }

    // Start the game after payment
    document.getElementById("payPlay").addEventListener("click", async () => {
      try {
        document.getElementById("payPlay").disabled = true;
        await requiredPayment();
        document.getElementById("intro").style.display = "none";
        lossCount = 0; // reset after payment
        startPong();
      } catch(e) {
        show("‚ùå Payment required to play.");
      } finally {
        document.getElementById("payPlay").disabled = false;
      }
    });

    // ÿπŸÜÿØ ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© 3 ŸÖÿ±ÿßÿ™ÿå ÿ™ÿ±ÿ¨ÿπ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ£ŸàŸÑŸâ
    async function handleLoss(){
      lossCount++;
      if (lossCount >= 3) {
        alert("üí∏ You lost 3 times! Please pay again to continue.");
        lossCount = 0;
        document.getElementById("intro").style.display = "grid";
        document.getElementById("status").innerHTML = "";
      }
    }

    function startPong(){
      const canvas = document.getElementById('game');
      const context = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      const grid = Math.max(10, canvas.width / 50);
      const paddleHeight = grid * 5;
      const maxPaddleY = canvas.height - grid - paddleHeight;
      let paddleSpeed = 6, ballSpeed = 4;

      const bot = { x:grid*2, y:canvas.height/2 - paddleHeight/2, width:grid, height:paddleHeight };
      const player = { x:canvas.width - grid*3, y:canvas.height/2 - paddleHeight/2, width:grid, height:paddleHeight, dy:0 };
      const ball = { x:canvas.width/2, y:canvas.height/2, width:grid, height:grid, dx:ballSpeed, dy:-ballSpeed, resetting:false };

      function collides(a,b){ return a.x<b.x+b.width && a.x+a.width>b.x && a.y<b.y+b.height && a.y+a.height>b.y; }

      function loop(){
        requestAnimationFrame(loop);
        context.clearRect(0,0,canvas.width,canvas.height);

        // Player movement
        player.y += player.dy;
        if(player.y < grid) player.y = grid;
        else if(player.y > maxPaddleY) player.y = maxPaddleY;

        // Bot movement
        const botCenter = bot.y + bot.height / 2;
        if (botCenter < ball.y - 10) bot.y += paddleSpeed * 0.6;
        else if (botCenter > ball.y + 10) bot.y -= paddleSpeed * 0.6;
        if(bot.y < grid) bot.y = grid;
        else if(bot.y > maxPaddleY) bot.y = maxPaddleY;

        // Ball movement
        ball.x += ball.dx;
        ball.y += ball.dy;

        if(ball.y < grid || ball.y + grid > canvas.height - grid){ ball.dy *= -1; }

        // Reset ball if out
        if((ball.x < 0 || ball.x > canvas.width) && !ball.resetting){
          ball.resetting = true;
          if (ball.x > canvas.width) handleLoss(); // Player lost
          setTimeout(()=>{
            ball.resetting = false;
            ball.x = canvas.width/2;
            ball.y = canvas.height/2;
            ball.dx = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = ballSpeed * (Math.random() > 0.5 ? 1 : -1);
          },400);
        }

        // Collisions
        if(collides(ball, bot)){ ball.dx *= -1; ball.x = bot.x + bot.width; }
        else if(collides(ball, player)){ ball.dx *= -1; ball.x = player.x - ball.width; }

        // Draw
        context.fillStyle='white';
        context.fillRect(bot.x, bot.y, bot.width, bot.height);
        context.fillRect(player.x, player.y, player.width, player.height);
        context.fillRect(ball.x, ball.y, ball.width, ball.height);

        // Walls + midline
        context.fillStyle='lightgrey';
        context.fillRect(0,0,canvas.width,grid);
        context.fillRect(0,canvas.height-grid,canvas.width,canvas.height);
        for(let i=grid;i<canvas.height-grid;i+=grid*2)
          context.fillRect(canvas.width/2-grid/2,i,grid,grid);
      }

      // Controls
      document.addEventListener('keydown',e=>{
        if(e.which===38) player.dy=-paddleSpeed;
        else if(e.which===40) player.dy=paddleSpeed;
      });
      document.addEventListener('keyup',e=>{
        if([38,40].includes(e.which)) player.dy=0;
      });

      // Mobile controls
      const upBtn = document.getElementById('btn-up');
      const downBtn = document.getElementById('btn-down');
      const handleTouchStart = (dir) => { player.dy = dir === 'up' ? -paddleSpeed : paddleSpeed; };
      const handleTouchEnd = () => { player.dy = 0; };
      upBtn.addEventListener('touchstart', () => handleTouchStart('up'));
      downBtn.addEventListener('touchstart', () => handleTouchStart('down'));
      upBtn.addEventListener('touchend', handleTouchEnd);
      downBtn.addEventListener('touchend', handleTouchEnd);

      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
